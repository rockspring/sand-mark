这些系统调用创建和操作一个定时器，定时器通过文件描述符递送定时器过期通知。

他们提供了使用setitimer(2) 或 timer_create(2)的替代方式，优势是文件描述符可以被select(2), poll(2) 和 epoll(7)监控。

timerfd_create

timerfd_create创建一个新的timer对象，返回一个引用此对象的文件描述符。clockid参数规定了定时器记时用的时钟，要么是CLOCK_REALTIME，要么是CLOCK_MONOTONIC。CLOCK_REALTIME是一个可以设定的系统时钟。CLOCK_MONOTONIC是不可设定的时钟，不受系统时钟的不连续变化（手动改变系统时间）的影响。时钟的当前值可以通过使用clock_gettime(2)检索出来。

从Linux 2.6.27开始，下面的值设为flags参数改变timerfd_create的行为：

TFD_NONBLOCK 新打开文件时设置TFD_NONBLOCK文件状态标记。使用这个标记省去了额外调用fcntl(2)获得同样结果。

TFD_CLOEXEC 新打开文件时设置close-on-exec (FD_CLOEXEC)标记。

Linux的2.6.26版本及以下版本这个标记必须设置为0。

int timerfd_settime(int fd, int flags,
                           const struct itimerspec *new_value,
                           struct itimerspec *old_value);

timerfd_settime启动或停止通过文件描述符引用的定时器。

new_value参数规定了初始过期时间和定时器的间隔。new_value的结构如下。

```
struct timespec {
   time_t tv_sec;                /* Seconds */
   long   tv_nsec;               /* Nanoseconds */
};

struct itimerspec {
   struct timespec it_interval;  /* Interval for periodic timer */
   struct timespec it_value;     /* Initial expiration */
};
```

设置new.it_value的tv_sec和tv_nsec中任何一个为非0，启动定时器；两个都设置为0，停止定时器。

设置new_value.it_interval中的tv_sec和tv_nsec一个或两个为非0，规定了定时器的间隔，定时器过期后在重复计时。如果两个值都设置为0，则定时器仅过期一次。

flags参数，设置为0，启动一个相对定时器，new_value.it_value规定了一个相对于定时器所用时钟的当前时间的一个时间；设置为TFD_TIMER_ABSTIME，启动一个绝对定时器，new_value.it_value规定了一个定时器所用时钟的绝对时间。

如果old_value不为NULL，用于接收当前定时器的设置。

timerfd_gettime()

int timerfd_gettime(int fd, struct itimerspec *curr_value);

curr_value接收文件描述符fd引用的定时器的当前设置。

如果curr_value.it_value的两个字段都为空，说明定时器已经停止。如果至少有一个不为空，定时器还有多长时间过期，这个值是相对值，不管TFD_TIMER_ABSTIME是不是设置了。

curr_value.it_interval包含了定时器的定时间隔，如果它的两个字段都为0，说明这是一个一次性定时器。

Operating on a timer file descriptor

