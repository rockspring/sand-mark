# 32位浮点型数字与8位浮点型数字之间的转换规则--org.apache.lucene.util.SmallFloat源码解读


在java语言中，32位浮点数的类型名称为float。java中不存在8位浮点数类型，8位浮点数的实际表示类型使用byte类型。java中的float和byte都为有符号数据，既能表示正数，也能表示负数。


32位浮点数的存储格式参考[https://zh.wikipedia.org/wiki/IEEE_754](https://zh.wikipedia.org/wiki/IEEE_754)。


32位浮点数转换成8位浮点数，精度损失，存储空间减少，对于精度要求不高的应用场景非常合适，Lucene的ClassicSimilarity打分器就用了这个技术减小norm值的存储空间，减小为原来的25%。

32位浮点数与8位浮点数之间的转换可以有多种方式，不同方式对应不同的精度和取值范围，如下分别解读SmallFloat实现的两种方式

## 1，方式1

将32位浮点数转换成8位浮点数的方法如下

```
public static byte floatToByte315(float f)
```

将8位浮点数转换成32位浮点数的方法如下

```
public static float byte315ToFloat(byte b)
```

从8位浮点数转换成32位浮点数的方法开始更好理解整个转换规则，下面分别举例说明这个转换规则

### 1.1，例子1

将byte类型表示的1转换成float类型表示的5.820766E-10，这是byte能够压缩存储的最小的大于0的32位浮点数

![graphs/SmallFloat-byte315ToFloat-example1.png](graphs/SmallFloat-byte315ToFloat-example1.png)

```
b = 0b00000001 = 1（解释为8位有符号int，10进制）= 1（解释为8位无符号int，10进制）


// 第一步，产生的结果图解见图形中第一个二进制串

(b&0xff) << (24-3)

= 0b00000001 拼接21个0

= 0b000 00000001 000000000000000000000

= 0b00000000001000000000000000000000

= 2097152（解释为32位有符号int，10进制）


// 第二步，产生的结果图解见图形中第二个二进制串

(63-15) << 24

= 48 << 24

= 0b110000 << 24

= 0b110000 拼接24个0

= 0b00 110000 000000000000000000000000

= 0b00110000000000000000000000000000

= 805306368（解释为32位有符号int，10进制）


// 第三步，产生的结果图解见图形中第三个二进制串

((b&0xff) << (24-3)) + ((63-15) << 24)

= 0b00000000001000000000000000000000
+ 0b00110000000000000000000000000000

= 0b00110000001000000000000000000000

= 2097152（解释为32位有符号int，10进制）+ 805306368（解释为32位有符号int，10进制）

= 807403520（解释为32位有符号int，10进制）

= 0b0 01100000 01000000000000000000000

= (2 ** (96 - 127)) * (1.0 + 2097152.0/8388608.0)

= 5.820766E-10（解释为32位有符号float，10进制）
```

### 1.2，例子2

将byte类型表示的-1转换成float类型表示的7.5161928E9，这是byte能够压缩存储的最大的32位浮点数

![graphs/SmallFloat-byte315ToFloat-example2.png](graphs/SmallFloat-byte315ToFloat-example2.png)

```
b = 0b11111111 = -1（解释为8位有符号int，10进制）= 255（解释为8位无符号int，10进制）


// 第一步，产生的结果图解见图形中第一个二进制串

(b&0xff) << (24-3)

= 0b11111111 拼接21个0

= 0b000 11111111 000000000000000000000

= 0b00011111111000000000000000000000

= 534773760（解释为32位有符号int，10进制）


// 第二步，产生的结果图解见图形中第二个二进制串

(63-15) << 24 = 48 << 24

= 0b110000 << 24

= 0b110000 拼接24个0

= 0b00 110000 000000000000000000000000

= 0b00110000000000000000000000000000

= 805306368（解释为32位有符号int，10进制）


// 第三步，产生的结果图解见图形中第三个二进制串

((b&0xff) << (24-3)) + ((63-15) << 24)

= 0b00011111111000000000000000000000
+ 0b00110000000000000000000000000000

= 0b01001111111000000000000000000000

= 534773760（解释为32位有符号int，10进制）+ 805306368（解释为32位有符号int，10进制）

= 1340080128（解释为32位有符号int，10进制）

= 0b0 10011111 11000000000000000000000

= (2 ** (159 - 127)) * (1.0 + 6291456.0/8388608.0)

= 7.5161928E9（解释为32位有符号float，10进制）
```

### 1.3，float压缩转换成byte

上面描述的byte解压缩到float的逆向工程，需要处理如下边界情况

((63-15)<<3) = 384

float数字截掉尾部21位后，如果比384小，则向下溢出了，如果float数字为负数，转换成0，否则转换成1

((63-15)<<3) + 0x111 = 384 + 255 = 639

float数字截掉尾部21位后，比639大，则向上溢出了，转换成-1

## 2，方式2

将32位浮点数转换成8位浮点数的方法如下

```
public static byte floatToByte52(float f)
```

将8位浮点数转换成32位浮点数的方法如下

```
public static float byte52ToFloat(byte b)
```

从8位浮点数转换成32位浮点数的方法开始更好理解整个转换规则，下面分别举例说明这个转换规则

### 2.1，例子1

将byte类型表示的1转换成float类型表示的0.033203125，这是byte能够压缩存储的最小的大于0的32位浮点数

![graphs/SmallFloat-byte52ToFloat-example1.png](graphs/SmallFloat-byte52ToFloat-example1.png)

```
b = 0b00000001 = 1（解释为8位有符号int，10进制）= 1（解释为8位无符号int，10进制）


// 第一步，产生的结果图解见图形中第一个二进制串

(b&0xff) << (24-5)

= 0b00000001 拼接19个0

= 0b00000 00000001 0000000000000000000

= 0b00000000000010000000000000000000

= 524288（解释为32位有符号int，10进制）


// 第二步，产生的结果图解见图形中第二个二进制串

(63-2) << 24

= 61 << 24

= 0b110000 << 24

= 0b110000 拼接24个0

= 0b00 111101 000000000000000000000000

= 0b00111101000000000000000000000000

= 1023410176（解释为32位有符号int，10进制）


// 第三步，产生的结果图解见图形中第三个二进制串

(b&0xff) << (24-5) + (63-2) << 24

= 0b00000000000010000000000000000000
+ 0b00111101000000000000000000000000

= 0b00111101000010000000000000000000

= 524288（解释为32位有符号int，10进制）+ 1023410176（解释为32位有符号int，10进制）

= 1023934464（解释为32位有符号int，10进制）

= 0b0 01111010 00010000000000000000000

= (2 ** (122 - 127)) * (1.0 + 524288.0/8388608.0)

= 0.033203125（解释为32位有符号float，10进制）
```

### 2.2，例子2

将byte类型表示的-1转换成float类型表示的1984.0，这是byte能够压缩存储的最大的32位浮点数

![graphs/SmallFloat-byte52ToFloat-example2.png](graphs/SmallFloat-byte52ToFloat-example2.png)

```
b = 0b11111111 = -1（解释为8位有符号int，10进制）= 255（解释为8位无符号int，10进制）


// 第一步，产生的结果图解见图形中第一个二进制串

(b&0xff) << (24-5)

= 0b00000001 拼接19个0

= 0b00000 11111111 0000000000000000000

= 0b00000111111110000000000000000000

= 133693440（解释为32位有符号int，10进制）


// 第二步，产生的结果图解见图形中第二个二进制串

(63-2) << 24

= 61 << 24

= 0b110000 << 24

= 0b110000 拼接24个0

= 0b00 111101 000000000000000000000000

= 0b00111101000000000000000000000000

= 1023410176（解释为32位有符号int，10进制）


// 第三步，产生的结果图解见图形中第三个二进制串

(b&0xff) << (24-5) + (63-2) << 24

= 0b00000111111110000000000000000000
+ 0b00111101000000000000000000000000

= 0b01000100111110000000000000000000

= 133693440（解释为32位有符号int，10进制）+ 1023410176（解释为32位有符号int，10进制）

= 1157103616（解释为32位有符号int，10进制）

= 0b0 10001001 11110000000000000000000

= (2 ** (137 - 127)) * (1.0 + 7864320.0/8388608.0)

= 1984.0（解释为32位有符号float，10进制）
```

### 2.3，float压缩转换成byte

上面描述的byte解压缩到float的逆向工程，需要处理如下边界情况

(63-2)<<5) = 1952

float数字截掉尾部19位后，如果比1952小，则向下溢出了，如果float数字为负数，转换成0，否则转换成1

((63-2)<<5) + 0x111 = 1952 + 255 = 2207

float数字截掉尾部19位后，比2207大，则向上溢出了，转换成-1


## 3 参考资料

[https://github.com/apache/lucene-solr/blob/releases/lucene-solr/6.2.1/lucene/core/src/java/org/apache/lucene/util/SmallFloat.java](https://github.com/apache/lucene-solr/blob/releases/lucene-solr/6.2.1/lucene/core/src/java/org/apache/lucene/util/SmallFloat.java)