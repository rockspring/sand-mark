# 执行引擎执行计划

## 纯粹并集

```
excl(req(subs.get(Occur.FILTER), subs.get(Occur.MUST), randomAccess), subs.get(Occur.MUST_NOT));
```

## 纯粹或集

```
excl(opt(subs.get(Occur.SHOULD), minShouldMatch, needsScores, randomAccess), subs.get(Occur.MUST_NOT));
```

## conjunction-disjunction mix，minNrShouldMatch > 0

ConjunctionScorer

## conjunction-disjunction mix，minNrShouldMatch = 0

ReqOptSumScorer


# 引擎执行计划详解

```
private Scorer req(Collection<ScorerSupplier> requiredNoScoring, Collection<ScorerSupplier> requiredScoring, boolean randomAccess) throws IOException;
```

requiredNoScoring是Occur.FILTER类型的查询语句，不需要打分

requiredScoring是Occur.MUST类型的查询语句，需要打分

如果只有一个requiredNoScoring或一个requiredScoring，且不需要分数，返回requiredNoScoring或requiredScoring拆包出来的Scorer。

如果BooleanWeight期望打分，实际上只有一个filter查询子句（requiredNoScoring的大小为1），返回一个FilterScorer，包装Scorer，分数设置为0。

如果requiredNoScoring的数量加上requiredScoring的数量大于1，则构建ConjunctionScorer。先求出requiredNoScoring和requiredScoring包含的ScorerSupplier最低的代价minCost。对于代价大于minCost的ScorerSupplier，强制使用随机访问randomAccess方式获取Scorer，否则根据Boolean2ScorerSupplier的randomAccess值决定。

```
private Scorer opt(Collection<ScorerSupplier> optional, int minShouldMatch, boolean needsScores, boolean randomAccess) throws IOException;
```

如果optional大小为1，则返回optional里的ScorerSupplier获取的Scorer。

如果minShouldMatch小于1，则构建DisjunctionSumScorer。

如果minShouldMatch大于1，则构建MinShouldMatchSumScorer。

```
private Scorer excl(Scorer main, Collection<ScorerSupplier> prohibited) throws IOException;
```

ReqExclScorer
