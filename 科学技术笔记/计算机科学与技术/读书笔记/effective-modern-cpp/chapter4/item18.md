# 第18条：使用std::unique_ptr实现资源管理的排他性所有权

2017年7月29日 7:30

假设std::unique_ptr与原始指针大小一样是合理的。对大多数操作（包括提领操作），他们执行的指令是一样的。如果原始的指针足够小、足够快，std::unique_ptr也同样适用。

## 排他性语义

std::unique_ptr体现了排他性语义。因此，它是一个只有可以移动不可以复制的类型。

使用场景：

1，创建一个层次结构类的中对象的工厂函数的返回类型。

方法工厂里创建的对象的所有权转移给调用工厂方法的调用者，调用者负责资源的管理。

代码实例：

item18_factory_function.cpp

2，所有权迁移场景，将工厂创建的对象的std::unique_ptr移动到一个容器里，将容器里的元素移动到一个对象的数据成员变量里，最后这个指针指向的对象被销毁。如果所有权迁移链路由于异常或其它非典型控制流（如循环中的过早退出或打断），std::unique_ptr最终也会被析构，它管理的资源也会被销毁。

## 自定义deleter

默认情况下，std::unique_ptr的析构函数会使用delete对其管理的对象进行析构。可以在构造std::unique_ptr的时候传递一个自定义的deleter，可以是任意函数（函数对象、lambda表达式）。

使用场景：

对象销毁之前先记录日志。

代码实例：

item18_factory_function_custom_deleter.cpp



2017年7月29日 9:30
